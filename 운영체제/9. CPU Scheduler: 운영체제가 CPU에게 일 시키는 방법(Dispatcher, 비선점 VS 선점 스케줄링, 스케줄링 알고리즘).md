   
   
 

## 💋 CPU 스케줄러와 Dispatcher

[##_Image|kage@K6Nza/btsAJEm09E6/kPkYdJqtkUgZTKavPhZvnk/img.png|CDM|1.3|{"originWidth":1046,"originHeight":583,"style":"alignCenter","width":808,"height":450,"caption":"이미지 출처:&amp;amp;nbsp;https://www.notesjam.com/2018/07/cpu-scheduling-in-operating-system.html"}_##]

   
 

### ✔️ **CPU 스케줄러 (CPU Scheduler)**

-   여러 프로세스 사이에서 CPU를 할당
-   CPU 사용률을 최대화하고 응답 시간을 최소화하여 시스템 성능을 향상시키는 것이 목적
-   프로세스 스케줄링 알고리즘을 사용하여 어떤 프로세스가 CPU를 사용할지 결정하며, **준비 큐(Ready Queue)에서 대기 중인 프로세스 중 하나를 선택**합니다.

### ✔️ **디스패처 (Dispatcher)**

-   CPU 스케줄러가 선택한 프로세스를 **실행 가능한 상태로 만들어주는** 역할
-   프로세스가 CPU를 점유하고 실행될 수 있도록 해당 프로세스를 실제로 CPU에 할당
-   **기능:** 디스패처는 **Context Switching**(프로세스의 상태를 변경하고, CPU 레지스터와 메모리 상태를 변경 등 현재 실행중인 프로세스의 상태를 저장하고, 다음 실행될 프로세스의 상태를 로드하는 과정)을 진행하며, **CPU의 모드 전환**(커널모드 ↔ 유저모드)해 하여 프로세스 실행 준비를 합니다.

## 💋 비선점 스케줄링 VS 선점 스케줄링

### ✔️ **비선점 방식 (Non-Preemptive Scheduling)**

-   **운영체제의** **_적극적인 개입 없이_****, 프로세스가** **_자발적으로_** **상태를 변환하는 방식**

-   하나의 프로세스가 CPU를 할당받아 실행 중일 때, 다른 프로세스가 강제로 CPU를 빼앗을 수 없습니다.

-   **장점:** 간단하고 예측 가능한 스케줄링을 제공하며, context switching에 따른 오버헤드가 낮습니다.
-   **단점:** 응답 시간이 예측하기 어렵고, 시스템의 전반적인 성능을 높이기 어려울 수 있습니다.

   
비선점 방식은 신사적이고, 협력적(cooperative)인 특징을 지니고 있습니다.  
프로세스가 ‘자발적으로’ 상태가 바뀐다는 것에 대해 예시를 통해 추가적으로 알아봅시다.  
   
   
 

[##_Image|kage@cKSpdY/btsANuZdYUJ/hSWVfVUn7U8OQDNpHSWI80/img.png|CDM|1.3|{"originWidth":1014,"originHeight":424,"style":"alignCenter","width":1014,"height":424}_##]

1.  **`Running`****에서** **`Ready`****로 자발적 전환**

-   현재 실행 중인 프로세스가 특정 이벤트를 기다려야 하는 경우
-   condition variable에 따라서, **조건이 충족되지 않아 wait에 들어가는 경우**입니다.
-   이 조건은 예를 들어 사용자가 특정 키를 누르거나, 네트워크에서 데이터를 수신하는 등의 상황이 될 수 있습니다.

3.  **`Running`****에서** **`Waiting`****으로 자발적 전환**

-   외부 리소스를 기다리는 경우
-   파일을 읽거나 쓰기 위해 **디스크 I/O를 기다리는 경우**입니다.

5.  **`Running`****에서** **`Terminated`****로 자발적 전환**

-   프로세스가 자신의 작업을 완료하고 종료해야 하는 경우
-   특정 계산이나 작업이 끝나면 프로세스는 자발적으로 Terminated 상태로 전환하여 종료됩니다.

   
 

### ✔️ **선점 방식 (Preemptive Scheduling)**

-   **운영체제의** **_적극적인 개입_****으로, 프로세스를 스케줄링하는 방식**
    -   quantum이 지나면 Ready Queue에 넣어버린다거나, 우선순위 높은 프로세스가 I/O 작업을 마치고 `Waiting`에서 `Ready`로 전환된 경우, 이미 실행중이던 프로세스가 있더라도 context switching을 할 수 있습니다.

-   운영체제는 비선점 방식에서의 모든 동작에 추가로, 개입하게 됩니다.

-   어떤 프로세스가 실행 중일 때도 스케줄러에 의해 우선순위가 높은 다른 프로세스가 도착하면 실행 중인 프로세스가 일시 중단되고, 새로운 프로세스가 CPU를 할당받습니다.
-   응답 시간을 예측하기 쉽고, 시스템 전체적인 성능을 향상시킬 수 있습니다.
-   context switching에 따른 오버헤드가 증가하며, 프로세스 간의 경쟁이 발생할 수 있습니다.

   
선점 방식은 적극적이고, 강제적인 특징을 지니고 있습니다.  
CPU가 동작하다가, [강제로 context switching을 당하는 경우에, 데이터의 일관성 문제가 발생](/f9ad9c27fec44487a7de47937398a727)해, 앞서 계속해서 학습했던 critical section에 대한 필요성이 있습니다.  
   
 

## 💋 스케줄링 알고리즘

마지막으로, 간단하게 여러 가지 스케줄링 알고리즘에 대해서 알아보겠습니다.  
간단한 소개 정도이니, 깊게 공부하려면 별도로 공부해야 합니다!  
 

### **✔️ FCFS (First-Come, First-Served)**

-   먼저 도착한 프로세스가 먼저 CPU를 할당받는 방식
-   간단하고 공정한 방식이지만, 평균 대기 시간이나 응답 시간이 길어질 수 있습니다.

[##_Image|kage@KnU4v/btsAMWn7ahl/2PgEc7SqjKdxBOVHUivVL1/img.png|CDM|1.3|{"originWidth":300,"originHeight":78,"style":"alignCenter"}_##]

### **✔️** **SJF (Shortest Job First)**

-   실행 시간이 가장 짧은 프로세스를 먼저 실행하는 방식입
-   최적의 평균 대기 시간을 제공할 수 있지만, 실행 시간을 정확히 예측하기 어려운 단점이 있습니다.

[##_Image|kage@y9wwk/btsALJQujhu/UbQpKHw0kpc54gD9nHes20/img.png|CDM|1.3|{"originWidth":300,"originHeight":78,"style":"alignCenter"}_##]

### **✔️** **SRTF (Shortest Remaining Time First)**

-   SJF의 선점 버전
-   현재 실행 중인 프로세스보다 남은 실행 시간이 더 짧은 프로세스가 도착하면 교체합니다.
-   최적의 평균 대기 시간을 제공할 수 있으며, 선점으로 인한 유연성이 있습니다.

### **✔️** **Priority Scheduling**

-   각 프로세스에 우선순위를 할당하고, 우선순위가 높은 순서대로 CPU를 할당하는 방식
-   우선순위를 어떻게 정하느냐에 따라 다양한 결과가 나오며, 높은 우선순위를 갖는 프로세스가 계속 실행되는 상태가 될 수 있습니다.

### **✔️** **RR (Round Robin)**

-   앞서 학습한 [CPU의 멀티태스킹](https://engineerinsight.tistory.com/281#%E2%9C%94%EF%B8%8F%C2%A0%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9-1)과 가장 유사한 방식입니다.

-   각 프로세스에 일정한 시간(타임 슬라이스)을 할당하고, 시간이 다 되면 다음 프로세스로 넘어가는 방식
-   공정한 방식이지만, 프로세스의 실행 시간이 다양한 경우에는 평균 대기 시간이 늘어날 수 있습니다.

[##_Image|kage@S1NZc/btsANMMeB0U/LH1Tg7K5CAF4ZiEdLkzV6k/img.png|CDM|1.3|{"originWidth":300,"originHeight":76,"style":"alignCenter"}_##]

### **✔️** **Multilevel Queue Scheduling**

-   프로세스를 그룹화해서, 그룹별로 Queue를 만드는 방식
-   프로세스를 여러 개의 큐로 나누고, 각 큐에는 서로 다른 우선순위를 부여합니다.
-   각 큐마다 독립적인 스케줄링 알고리즘을 적용합니다.
-   다양한 우선순위의 프로세스를 처리하면서 다양한 스케줄링 정책을 적용할 수 있습니다.

   
   
위에서 설명한 알고리즘을 자세히 생각해 보면, 중간에 운영체제가 개입해서 순서를 바꾸는지에 따라서 또 이렇게 나눌 수 있습니다.   
 

[##_Image|kage@G8u8g/btsANNRXNeg/YhEXCjWnCIPBrGRRINBL8K/img.png|CDM|1.3|{"originWidth":1064,"originHeight":582,"style":"alignCenter","caption":"이미지 출처:&amp;amp;nbsp;https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/"}_##]

   
 

## 💋 참고자료

-   [https://www.baeldung.com/cs/process-scheduling](https://www.baeldung.com/cs/process-scheduling)
-   [https://www.youtube.com/watch?v=LgEY4ghpTJI&list=PLcXyemr8ZeoQOtSUjwaer0VMJSMfa-9G-&index=9](https://www.youtube.com/watch?v=LgEY4ghpTJI&list=PLcXyemr8ZeoQOtSUjwaer0VMJSMfa-9G-&index=9)
-   [https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/)

   
   
 

[##_Image|kage@z97bp/btsAKUdG9YX/tUoFMu0adB6YWkflG4rwl1/img.jpg|CDM|1.3|{"originWidth":1954,"originHeight":1954,"style":"alignCenter","width":367,"height":367}_##]

> 도움이 되었다면, 공감/댓글을 달아주면 **깃짱**에게 큰 힘이 됩니다!🌟  
> _**비밀댓글과 메일을 통해 오는 개인적인 질문은 받지 않고 있습니다. 꼭 공개댓글로 남겨주세요!**_
